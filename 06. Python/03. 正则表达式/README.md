测试正则表达式：<https://regex101.com/>

正则表达式练习：<https://codejiaonang.com/#/courses>

|   正则符号   | 正则规则                                     | 例子                                       |
| :------: | ---------------------------------------- | ---------------------------------------- |
|    .     | 匹配除了换行符以外的任意一个字符                         |                                          |
|    *     | 对它前面的正则表达式匹配0到任意次重复， 尽量多的匹配（贪婪）          |                                          |
|    +     | 对它前面的正则表达式匹配1到任意次重复， 尽量多的匹配（贪婪）          |                                          |
|    ?     | 对它前面的正则表达式匹配0到1次， 尽量多的匹配（贪婪）             |                                          |
| *? +? ?? | * + ? 都是贪婪的，它们对字符串进行尽可能多的匹配，有时候并不需要这种行为，可以在之后添加 ?，就可以以非贪婪的方式进行匹配，则尽可能少的字符将会被匹配 |                                          |
|    []    | 用于表示一个字符集，字符可以单独列出，比如 [amk] 匹配 'a'， 'm'， 或者 'k'特殊字符在字符集中，失去它的特殊含义，例如[.+]就是匹配.或者+，\d \s \w 依然可以被接受不在字符集范围内的字符可以通过取反来进行匹配，如果字符集首字符是 ^ ，所有不在字符集内的字符将会被匹配， ^ 如果不在字符集首位，就没有特殊含义 | p = re.compile(r"[amk]")print(p.findall("I have a monkey"))>>['a', 'a', 'm', 'k'] |
|   {m}    | 对其之前的正则表达式指定匹配 m 个重复                     |                                          |
|  {m,n}   | 对其之前的正则表达式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多（贪婪方式） |                                          |
|  {m,n}?  | 上面 {m,n} 的非贪婪模式                          |                                          |
|          |                                          |                                          |
|    ^     | 第一种作用：脱：匹配除了^以外的（此时^必须放在[]区间内使用才是脱得作用）第二种作用：匹配整个字符串的开头。MULTILINE 模式下，还会继续匹配换行后的开头。 | p =re.compile(r"^ab")print(p.findall("abcd\nabfg"))p = re.compile(r"^ab", flags=re.MULTILINE)print(p.findall("abcd\nabfg")) |
|    $     | 匹配字符串的末尾 或者 匹配在字符串末尾的换行符之前的字符MULTILINE 模式下，还会匹配换行符之前的字符 | p = re.compile(r"d$")print(p.findall("abcd\n"))>>['d']p = re.compile(r"d$")print(p.findall("abcd\nd"))>>['d'] |
|    \     | 转义字符：将正则表达式中所有的特殊字符转义为普通字符               |                                          |
|    \|    | 任意个正则表达式可以用 \| 连接，比如 A\|B 表示匹配正则表达式 A 或者 B，一旦有一个先匹配成功，另外的就不会再进行匹配，\| 绝不贪婪 | \[\]\|\-+\|\(\)可以匹配[] --- ()             |

| 正则符号       | 正则规则                                     | 例子                                       |
| ---------- | ---------------------------------------- | ---------------------------------------- |
| （）和\number | 匹配数字代表的分组里面的内容，\number匹配到的内容和对应分组匹配到的必须一模一样 | p = re.compile(r"b(.+)a(\1)e")m = p.match("babacdefg")>> 'babacde'p.findall("babacdefg")>>[('ab', 'ab')] |
| (?:…)      | 非捕获分组，想使用括号而且不想提取括号内匹配的内容。并不创建新的组合，所匹配的子字符串不能在执行匹配后被获取或是之后在模式中被引用 | p = re.compile(r"b(?:.+)a(?:.+)e")m = p.findall("babacdefg")>>['babacde'] |
| \d         | 匹配任何一个十进制数字，等价于 [0-9]                    |                                          |
| \w         | 匹配一个字母或一个数字或一个下划线，等价于 [a-zA-Z0-9_]       |                                          |
| \s         | 匹配所有空白：空格，tab，换行等                        |                                          |
| \S         | 匹配所有非空白                                  |                                          |
| \b         | 匹配空字符串，但只在单词开始或结尾的位置，即匹配一个单词边界           |                                          |
| \B         | 匹配空字符串，但不能在单词开始或结尾的位置，即匹配非单词边界           |                                          |
| \D         | 匹配任何非数字字符，等价于 [^0-9]                     |                                          |
| \W         | 匹配非字母数字下划线，等价于 [^a-zA-Z0-9_]             |                                          |
| \Z         | 只匹配字符串的末尾，且 MULTILINE 模式下，\Z 不识别换行       |                                          |

| 正则符号 | 正则规则                                 | 例子                                       |
| ---- | ------------------------------------ | ---------------------------------------- |
|      |                                      |                                          |
| .    | 匹配任意字符但是不能匹配\n换行符                    |                                          |
| ?    | 可选字符：出现0次或者1次；或者启动非贪婪模式，尽可能少的字符将会被匹配 | favou?rite可以匹配favourite或者favorite；\d{8,9}会优先匹配9个字的数字\d{8,9}?启动非贪婪模式，会优先匹配8个数字 |
| {}   | {}内代表可重复的次数或者区间，取尽量多（贪婪方式）           |                                          |
| +    | 相当于{1，}匹配一次到无穷大次                     |                                          |

| 正则符号     | 正则规则                                     | 例子                                       |
| -------- | ---------------------------------------- | ---------------------------------------- |
| \1或者\2等等 |                                          | 例如要使用匹配提示但是不能匹配提示因为后者标签编写根本不正确，所以要回溯第一个分组。所以正则应该写为：<(\w+)>(.*?)其中\1代表回溯第一个分组 |
| (?=表达式)  | 从左往右看：表示符合条件的字符串必须包含(?=)中的条件，但是却不提取(?=)中的符合条件的内容 | 例1：匹配包含至少一个小写字母或者大写字母的字符串(?=.*?[a-z])(?=.*?[A-Z]).+例2：匹配至少一个大写字母，至少一个小写字母，至少一个数字，至少8个字符(?=.?[a-z])(?=.?[A-Z])(?=.*?[0-9]).{8,}例3：匹配我喜欢你的喜欢，而且喜欢后面必须有你喜欢(?=你) |
| (?!表达式)  | 从左往右看：表示符合条件的字符串必须不包含(?!)中的条件，但是却不提取(?!)中的符合条件的内容 | 例1：匹配我喜欢他的喜欢，而且喜欢后面必须没有你喜欢(?!你)          |
| (?       | 从右往左看：先行断言和后行断言只有一个区别，即先行断言从左往右看，后行断言从右往左看。正向后行断言：(?<=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配表达式 | 例如：如果要取出喜欢两个字，要求喜欢的前面有我，后面有你，这个时候就要这么写：(?<=我)喜欢(?=你)。 |

| 正则名称   | 正则符号 | 正则规则     | 例子                                       |
| ------ | ---- | -------- | ---------------------------------------- |
| 反向后行断言 | (?   | 从右往左看：(? | 例如：如果要取出喜欢两个字，要求喜欢的前面没有我，后面没有你，这个时候就要这么写：(? |

| 编译正则表达式                                  | re.compile(pattern, flags=0)             | ，flags：标志，用于控制正则表达式的匹配方式，可以使用re.MULTILINE模式 |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| 执行匹配                                     | Pattern.search(string[, pos[, endpos]])  | 扫描整个字符串，寻找第一个成功的匹配                       |
| Pattern.match(string[, pos[, endpos]])   | 当字符串的起始位置匹配成功，返回Match类的实例对象p = re.compile('og')print(p.match("dog"))>>Noneprint(p.search("dog", 1))>>og |                                          |
| Pattern.fullmatch(string[, pos[, endpos]]) | 当整个字符串都匹配成功，返回Match类的实例对象                |                                          |
| Pattern.findall(string[, pos[, endpos]]) | 对字符串从左往右扫描，找到所有不重复匹配，以列表的形式返回（保存子串），如果有多个组，则返回元组列表，如果没有找到匹配的，则返回空列表 |                                          |
| Match 实例对象支持以下方法：                        | Match.group([group1, ...])               | 返回一个或者多个子组的匹配结果，如果有多个参数，结果就是一个元组         |
| Match.groups(default=None)               | 返回一个元组，包含所有子组的匹配结果                       |                                          |
| Match.start([group])                     | 返回对应 group 匹配开始的位置，group默认为 0            |                                          |
| Match.end([group])                       | 返回对应 group 匹配结束的位置，group默认为 0            |                                          |
| Match.span([group])                      | 返回一个元组，包含 (Match.start([group]), Match.end([group]))，group默认为 0 |                                          |
| 编译标志                                     | re.I / re.IGNORECASE                     | 进行忽略大小写匹配                                |
|                                          | re.M / re.MULTILINE                      | 多行匹配，影响 ^ 和 $，设置以后， ^ 匹配字符串的开始，和每一行的开始；$ 匹配字符串尾，和每一行的结尾 |
|                                          | re.S / re.DOTALL                         | 使 . 匹配包括换行在内的所有字符，没有设置时 . 是不能匹配换行符的      |
|                                          | re.X / re.VERBOSE                        | 允许你编写更具可读性的正则表达式，主要体现在分段、添加注释、空白符号       |